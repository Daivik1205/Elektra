import pandas as pd
import joblib
import numpy as np
import os
import sys

# Allow imports from parent
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

class SOHPredictor:
    def __init__(self):
        self.model_path = "models/elektra_soh_model.pkl"
        self.model = joblib.load(self.model_path) if os.path.exists(self.model_path) else None

        self.feature_order = [
            "cycle", "mean_voltage", "voltage_std", "min_voltage", "max_voltage",
            "capacity_ah", "capacity_ratio", 
            "anode_dvdq_area", "anode_dvdq_peak_count", "anode_dvdq_mean", # Note: Model might expect specific names
            "cathode_dvdq_area", "cathode_dvdq_peak_count", "cathode_dvdq_mean",
            "delta_capacity", "rolling_voltage_std"
        ]
        
        # Fallback names if your model uses the exact names from your snippet
        # (Assuming the model was trained with the keys generated by load_dvdq_features)

    def predict(self, dynamic_features, static_features):
        """
        dynamic_features: dict of changing values (cycle, voltage_std, etc.)
        static_features: dict of chemistry values (anode_dvdq_area, etc.)
        """
        
        # 1. Merge Static & Dynamic Features
        # "inject static chemistry features"
        combined_features = {**dynamic_features, **static_features}
        
        # 2. Create DataFrame
        df = pd.DataFrame([combined_features])
        
        # 3. Handle Missing Columns (Model safety)
        # We try to reindex to match the model's expected input feature vector
        # If specific columns like 'peak_count' are missing from the simple loader, we fill 0
        df = df.reindex(columns=self.feature_order, fill_value=0)
        
        # 4. Predict
        if self.model:
            pred = float(self.model.predict(df)[0])
        else:
            # Fallback Logic (if no model file exists)
            # Degrade based on cycle and instability
            cycle_penalty = dynamic_features.get('cycle', 0) * 0.05
            instability_penalty = dynamic_features.get('rolling_voltage_std', 0) * 100
            pred = 100.0 - cycle_penalty - instability_penalty
        
        return float(np.clip(pred, 0, 100))